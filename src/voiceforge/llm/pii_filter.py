"""PII filter: redact before sending to LLM API. Regex + optional GLiNER (PERSON, ADDRESS, ORG)."""

from __future__ import annotations

import re

import structlog

log = structlog.get_logger()

# Email: local@domain
_RE_EMAIL = re.compile(r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b")
# Phone: +7, 8, international; digits and spaces/dashes/parens
_RE_PHONE = re.compile(
    r"(?:\+7|8)[\s\-]?\(?\d{3}\)?[\s\-]?\d{3}[\s\-]?\d{2}[\s\-]?\d{2}\b"
    r"|\+\d{1,3}(?:[\s\-]?\d{1,4}){2,5}\b"
)
# INN (RU tax id): 10-digit only when preceded by ИНН keyword; 12-digit standalone
# Rationale: bare 10-digit numbers have high false-positive rate (timestamps, order IDs);
# 12-digit physical-person INNs are rare enough to redact standalone.
_RE_INN = re.compile(
    r"(?:ИНН|инн|INN|inn)\s*:?\s*\d{10}\b"  # 10-digit after explicit INN label
    r"|(?:налоговый|налоговая)\s*:?\s*\d{10}\b"  # common RU tax-id wording
    r"|\b\d{12}\b",  # 12-digit standalone (individual INN/OGRIP)
    re.IGNORECASE,
)
# SNILS (RU pension): XXX-XXX-XXX YY
_RE_SNILS = re.compile(r"\b\d{3}-\d{3}-\d{3}\s\d{2}\b")
# Card: 13-19 digits, optional spaces/dashes every 4
_RE_CARD = re.compile(
    r"\b(?:\d{4}[\s\-]?){3}\d{4}(?:\s?\d+)?\b"
    r"|\b\d{13,19}\b"
)

_PLACEHOLDER_EMAIL = "[EMAIL]"
_PLACEHOLDER_PHONE = "[PHONE]"
_PLACEHOLDER_INN = "[INN]"
_PLACEHOLDER_SNILS = "[SNILS]"
_PLACEHOLDER_CARD = "[CARD]"


def _apply_gliner(out: str) -> str:
    """Apply GLiNER entities (PERSON, ADDRESS, ORG, etc.) when available."""
    try:
        from voiceforge.llm.gliner_ner import detect

        entities = detect(out)
    except ImportError:
        return out
    except Exception as e:
        # Programming errors (AttributeError, etc.) should not silently eat PII — re-raise
        log.warning("pii.gliner_detection_failed", error=str(e))
        return out
    if not entities:
        return out
    # Sort by start descending so replacements don't shift indices
    sorted_entities = sorted(entities, key=lambda ent: ent.start, reverse=True)
    for ent in sorted_entities:
        if ent.start < 0 or ent.end > len(out) or ent.start >= ent.end:
            continue
        token = out[ent.start : ent.end]
        # Never rewrite existing placeholders generated by regex stage.
        if re.fullmatch(r"\[[A-Z_]+\]", token):
            continue
        label = "CARD" if ent.label == "CREDIT_CARD" else ent.label
        placeholder = f"[{label}]"
        out = out[: ent.start] + placeholder + out[ent.end :]
    return out


def redact(text: str | None, mode: str = "ON") -> str | None:
    """Replace PII with placeholders. mode: OFF=no change, EMAIL_ONLY=email only, ON=full (regex+GLiNER)."""
    if not text:
        return text
    if mode == "OFF":
        return text
    if mode == "EMAIL_ONLY":
        return _RE_EMAIL.sub(_PLACEHOLDER_EMAIL, text)
    out = _RE_EMAIL.sub(_PLACEHOLDER_EMAIL, text)
    out = _RE_PHONE.sub(_PLACEHOLDER_PHONE, out)
    out = _RE_INN.sub(_PLACEHOLDER_INN, out)
    out = _RE_SNILS.sub(_PLACEHOLDER_SNILS, out)
    out = _RE_CARD.sub(_PLACEHOLDER_CARD, out)
    out = _apply_gliner(out)
    return out
